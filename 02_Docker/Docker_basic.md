# Docker Container 

## 1.1 컨테이너 및 가상화

### 가상화 → 동작 방식에 따라 세분화

- 호스트 가상화
- 하이퍼바이저 가상화 → VirtualBox 가 하이퍼바이저
- 어플리케이션 가상화
- 네트워크 가상화
- 스토리지 가상화
- 컨테이너 가상화
</br></br>
### 1. 가상화 기술

- docker의 동작 방식, 장점을 이해하려면 ‘네이티브/베어메탈 가상화’, ‘호스트 가상화’, ‘컨테이너 가상화’ 방식에 대해 이해해야 한다.

- docker 는 컨테이너 가상화에 해당, 나머지 가상화 방식과 구동 방식에서 큰 차이가 있다.  
</br>

#### (1) 네이티브 / 베어메탈 가상화

- 네이티브/베어메탈은 하드웨어인데, 깡통이야 아무 것도 없고. 하드웨어 위에 OS 대신 하이퍼바이저 SW를 설치한 뒤 가상 머신을 생성.

- 하이퍼바이저는 펌웨어 형태로 설치되며, 가상화를 지원하기 위해 필요한 양만큼의 자원만 사용하고 나머지는 전부 가상 머신의 구동에 사용
</br></br>
#### (2) 호스트 가상화

- 가장 일반적으로 사용하는 가상화 방식 중 하나로 호스트 OS는 윈도우, 리눅스, macOS 등을 의미.

- OS 내에서 응용프로그램 형태로 하이퍼바이저를 사용하므로, 가상 머신을 생성하고 관리하기 용이하지만 OS가 시스템 자원을 어느 정도 점유 

- 동일한 OS를 사용하는 다수의 가상 머신을 사용하더라도 OS가 커널부터 시작하여 모든 부분을 각각 구동하여야 하므로 오버헤드가 커지는 단점이 있다.

- 이게 VMware의 Workstaion, Oracle의 VirtualBox 등

</br></br>
(3) 컨테이너 가상화
- 네이티브 가상화와 호스트 가상화는 형태가 다소 다르긴 하지만, 가상 머신을 생성한 뒤 가상 머신에 운영체제를 설치해야 한다는 공통점이 있다.

- 컨테이너 가상화는 호스트 운영체제에서 가상 머신 형태가 아닌, 논리적으로 격리된 구역을 생성하여 어플리케이션, 어플리케이션에 필요한 라이브러리를 집어넣어 독립적인 어플리케이션이 동작하는 분리된 서버처럼 만드는 가상화 기법. 여기서 논리적으로 격리된 공간을 ‘컨테이너’라고 한다.

- 컨테이너 가상화는 개별 운영체제가 필요하지 않고, 호스트 운영체제의 일부분을 공유하는 방식을 사용하므로 호스트 가상화나 하이퍼바이저 가상화보다 오버헤드가 매우 적다.

- 가상의 운영체제 없이 어플리케이션의 동작에 필요한 바이너리 및 라이브러리 리소스만 사용하므로, 일반적인 프로세스 구동과 같이 가볍게 동작하면서도 격리된 실행환경을 보장한다.

</br></br>
## 1.2 도커 아키텍처 → 컨테이너
- 도커의 가장 큰 장점 중 하나는 ‘높은 이식성’ → 어느 시스템에서나 같은 이미지를 사용할 경우 동일한 작동환경을 제공

- 어플리케이션 개발 시 개발 환경, 테스트환경, 운영환경이 각각 달라 어려움이 있던 개발자 및 관리자에게 각광 받음.

</br>

### 1. 도커의 장점

#### (1) 게스트 운영체제 불필요

- 앞서 설명한 ‘컨테이너 가상화’의 특징을 갖고 있다. 도커에서 생성된 컨테이너는 별도의 운영체제를 필요로 하지 않으며 호스트 운영체제와 많은 부분을 공유하면서도 격리된 환경을 제공.

- 이를 통해 컨테이너 작동에 필요한 이미지 용량을 줄이고, 별도의 가상화 계층이 아닌 호스트 운영체제의 프로세스처럼 동작하는 특징 (리눅스 명령어 처럼)이 있어 성능의 낭비나 감소가 거의 없다.

#### (2) 이식성

- 전통적 방식의 어플리케이션 개발 시 어려운 점은 개발, 테스트, 운영 환경의 차이점으로 인한 문제. 도커를 사용할 경우, 각 컨테이너는 이미지로부터 독립된 동작환경을 구성하여 실제 물리 시스템 간의 차이를 완화하여 동일한 환경처럼 동작시킬 수 있다.

#### (3) 상호운용성

- 온-프레미스 환경 뿐 아니라 다양한 벤더의 시스템 및 클라우드 환경을 지원하고 있다. 어떠한 환경에서도 간편하게 구성할 수 있으며, 다양한 DevOps 오픈소스 소프트웨어와 연계가 가능하다는 장점도 있고.
</br></br>

### 2. 도커의 주요 기능

#### (1) 이미지 생성 및 관리

- 이미지 : 컨테이너를 구동하기 위한 데이터
- 원하는 어플리케이션을 동작시키기 위해서는 어플리케이션 동작에 필요한 프로그램, 관련된 라이브러리, 미들웨어, 네트워크 설정 등을 모두 포함한 이미지를 생성해야 한다.
- 만들어진 이미지는 컨테이너 생성시 템플릿처럼 불러들여 컨테이너마다 동일한 어플리케이션을 구동하게 할 수 있다.

#### (2) 이미지 공유

- Docker에는 기본 이미지 저장소를 제공하고 있다.
- 이미지 저장소는 리지스트리(Registry)라고 불리며, 기본적으로 제공되는 이미지 저장소는 Docker Hub
- 도커 사용자는 이 이미지를 베이스로 내용을 적용하여 새로운 이미지를 중첩시켜 독자적인 이미지를 생성할 수 있다.
- 물론 공유도 가능
- `docker` 명령어는 이러한 작업을 할 수 있는 기능을 제공하고 있다.

#### (3) 컨테이너 동작

- Docker는 **컨테이너 가상화 방식을 사용하여 컨테이너 단위의 서버를 구동**
- 이미지 상태의 데이터는 파일 형태로 저장되어 있으나 실행할 수 있도록 메모리에 올라가 있지는 않은 프로그램 형태와 유사
- 컨테이너는 실행을 통해 메모리에 프로그램의 실행을 위해 필요한 내용을 올려놓은 상태인 프로세스로 비유할 수 있다.
- 일반적인 가상화 방식과 달리 별도의 운영체제를 필요로 하지 않으므로 실행 속도가 빠르며 효율이 우수.
- Docker는 컨테이너끼리 접근할 수 없도록 ‘고립(isolation)’ 기술을 사용

 </br></br>

## 3. 도커의 동작을 위하여 사용되는 기능

- 도커 → 리눅스 커널에 기반을 둔 가상화 기술을 기반으로 동작하도록 구성
- 컨테이너 네트워크 기능을 제공하기 위한 기능 또한 리눅스 커널과 연관

#### (1) 네임스페이스

- 네임스페이스는 독립된 환경을 만들 때 사용하는 기능 중 하나

<네임스페이스 종류>
|네임스페이스|설명|
|---------|--|
|PID| PID와 프로세스를 분리, 네임스페이스가 서로 다른 프로세스는 서로 접근 불가|
|Network|namespace 별로 네트워크 장치, IP 주소, 포트 번호, 라우팅 테이블, 필터링 테이블 사용|
|UID|namespace 별로 독립적인 UID, GID 사용|
|MOUNT|namespace 별로 독립적인 마운트 포인트 사용|
|UTS|namespace 별로 독립적인 host name 사용|
|IPC|namespace 별로 독립적인 IPC 오브젝트 사용|
 </br>

#### (2) 제어 그룹

- 도커의 각 컨테이너는 호스트의 리소스를 공유하여 사용
- 리눅스 커널의 ‘cgroup’은 프로세스 또는 쓰레드(thread)를 그룹화하여 관리하는 기능 → 호스트의 CPU나 메모리를 그룹별로 제한할 수 있다
</br>

#### (3) 가상 브릿지와 가상 NIC
- 도커에서 생성한 컨테이너에는 각각 가상의 NIC(Network Interface Card)가 할당됨
  - eth0 → 물리적인 NIC, docker0 → eth0과 연결된 가상의 브릿지 네트워크
  - vethxxx → 컨테이너 별로 생성된 호스트의 가상 NIC 로 이는 컨테이너의 eth0과 연결

- 웹사이트 설치하려고 httpd 도 설치하고 mariadb도 설치하고, php 도 설치하고 → 도커를 쓰면 이미 구축된 이미지를 다운받아서 설치하면 그거로 환경 설절 끝
</br></br>

## 2.3 도커 컨테이너 관리
</br>

`⭐ 컨테이너가 무엇인지 정확하게 이해하고 시작하자` </br>
</br>

컨테이너는 해당 가상 환경에서 실행되는 프로세스 

- 포트 : 해당 컨테이너가 어떤 포트로 통신하고 있는지(보통 네트워크 연결되는 컨테이너 만든다.)
- run → 다운로드와 실행을 동시에 명령하는 명령어 → 이게 정말 중요하대

- `docker inspect hello`

    이미지, 컨테이너, 네트워크. 볼륨 → 도커 오브젝트 라고 한다.

- `docker create`

- `docker run` 하나로 대부분 할 수 있다

    쉘 → 입력과 출력을 끊임없이 하는 특수 프로그램(?) 같은 건 특별히 지정을 해줘야 한다.

    입력, 출력이 가능한 컨테이너를 만드려면 옵션 -it를 

    `docker run` → 컨테이너를 만들고 시작함, 이미지가 없으면 해당 이미지를 레지스트리에서 검색해서 다운받음
        
        = pull + create + start 

    `docker run --name [컨테이너 이름] centos`

    `docker run -it --name [컨테이너 이름] centos`

    → 위처럼ㄴ ‘-d’ 안붙이면 포그라운드에서 시작

    운영체제 컨테이널르

    -d : 백그라운드에서 시작

    이때 run은 없는 컨테이너를 입력했을 때만 가능

- `docker rm 컨테이너 이름`
  
  → 정지한 컨테이머나 삭제

- `docker rm -f 컨테이너 이름`
  
  → 실행중인 컨테이너도 삭제


`⭐ 리눅스에서 -f 옵션은 보통, (forse) 강제로의 의미`


- `docker attach`
    
    -itd로 돌아가는 쉘 같은 거에 붙는 거, 동시에 백그라운드에서 돌아가는 컨테이너에 붙을 때 사용
    
- 쉘은 입력을 받아서 출력을 해주는 프로세스인데, 컨테이너에서 쉘을 실행하면 터미널에 붙는 게 아니라서 입력 출력이 없어. 그러면 깡통 보고 있는 거지. 그래서 입력, 출력 기능까지 넣어줘야 쉘이라는 특수한 프로세스를 이용할 수 있는 거야. 그래서 -it 를 입력해주는 거고. 그리고 -d 옵션을 붙여주면 백그라운드에서 돌아가면 포그라운드에서 작업하고 있는 우리는 입력 출력을 우리 키보드 모니터로 가져오는 것을 할 수가 없다(?) 그래서 attach 로 백그라운드로 돌아가는 쉘에 붙어서 입력 출력을 포그라운드의 키보드와 모니터로 붙여주는 것
</br></br>

(3) 컨테이너 안에서 

C → 파일이 변경되었다기 보다는, 디렉터리 안에 내용물이 변경되었다 정도로 알고 있으면 되겠다

이미지를 도커 허브에서 다운로드 받은 다음에 다운 받은 이미지를 컨테이너로 실행하고 그 다음에 실행한 컨테이너를 ?

commit → 으로 만들면 이름도 랜덤으로 되고 이런 식을 만들지 말자

실제로 만들 때는 docker commit c1 ID/

`docker save -o img.tar httpd:latest hello-world:latest`

`docker rmi -f httpd:latest hello-world:latest`

`docker load -i img.tar`
</br></br>
(5) 컨테이너의 네트워크는 공부를 잘 해야합니다~!

- 도커 오브젝트 : 이미지, 컨테이너, 네트워크, 볼륨

- 이미지를 메모리에 올려서 가상 어쩌고 실행하는 게 컨테이너, 컨테이너가 여러 개일 때 컨테이너 끼리 통신도 가능하고 host pc에서 컨테이너에 접속이 가능하다.

- 네트워크 통신을 가능하게 해주는 ‘오브젝트가 네트워크’

- 도커를 설치하면 기본적으로 네트워크 오브젝트(객체)가 있다.(?) 기존에 우리가 알던 네트워크는 A와 B가 통신하는 거였고, 여기서 말하는 네트워크는 가상의 네트워크(?)

- 도커를 설치하면 리눅스 안에 가상의 네트워크가 만들어지는데, 호스트하고 연결하고 가상의 docker 0이라는 가상의 인터페이스가 만들어진는데, 얘가 컨테이너들을 연결하는 일종의 공유기가 된다. → 그리고 veth1, 2도 만들어 지는데, 얘는 스위치 역할을 한대.